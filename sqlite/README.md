# Makefile using SQLite3 as recipe shell

Sounds strange but ... why not use SQL as recipe ? 

This Makefile is a fully working proof of concept utilizing sqlite3. 

Please note that one of the major features of make - do only execute targets with updated dependencies - are mostly skipped by this proof.

## Prerequisites

- GNU make 

- SQLite3

## Usage

Change to this directory and execute 

- `make` to populate the database 

- `make clean` to clean up the database 

- `rm db.sqlite3` to remove the database file completely

## Example code

```make
# suppress verbose make output
MAKEFLAGS += --silent

# make sqlite the "shell" for make recipes
SHELL != sh -c "command -v sqlite3"
# empty default shell commandline options to apply for shell invocation
.SHELLFLAGS := -bail -separator ; -batch -header db.sqlite3 
# => from now on every shell invocation by make will be sqlite

# .ONESHELL tells make to execute a target recipe as a single SHELL call
# (by default make would execute a recipe line by line in separate SHELL calls
.ONESHELL:

# et voilÃ  : recipes can now be written in pure sqlite syntax :-)
all: create insert import report
	.print "# target name is '$@', depends on '$^'\n"

report: 
	SELECT * FROM foo

merge_data: import_data
	INSERT INTO foo(name, familyname) 
		SELECT * FROM data;
	DROP TABLE IF EXISTS data

import_data: create data.csv 
	.import data.csv data
	
import: import_data merge_data;

insert: create
	INSERT INTO foo 
		(name, familyname) 
	VALUES 
		('Erika', 'Mustermann'),
		('Max', 'Mustermann');

	INSERT INTO foo (name, familyname) VALUES ('John', 'Doe')

create: 
	CREATE TABLE 
		IF NOT EXISTS 
	foo 
		(id INTEGER PRIMARY KEY AUTOINCREMENT, name STRING, familyname STRING)

clean:
	DROP TABLE IF EXISTS foo;
	DROP TABLE IF EXISTS data;

# tell make that these targets are NOT meant to be files/directories
.PHONY: all create insert import clean import import_data merge_data
```

If you execute the example by executing `make` in a terminal you will get the following output (SQLite3 version may differ depending on what version you've installed)

```
id;name;familyname
1;Erika;Mustermann
2;Max;Mustermann
3;John;Doe
4;Martina;Musterfrau
5;Susanne;Muster
6;Maria;Musterfrau
7;Manu;Musterperson
# target name is 'all', depends on 'create insert import report'
```

# Opinionated tip: use `.RECIPEPREFIX`

make is a impressive but stone age old tool with a long history.

At the time of development (=> some decades ago ðŸ˜…) their authors thought it's a good idea to use `'\t'` as recipe prefix.

The result is one of the most asked questions from `make` novices : 

> When executing my Makefile I get the following error
> 
> ```
> Makefile:xx: *** missing separator.  Stop.
> ```
>
> What does that error mean ? 

## What is the recipe prefix ?

A Makefile consists mostly of targets and their recipes. 

A target is usually a file/directory to be generated by the target recipe. 

An example: 

```make
foo.exe: foo.c
  cc -o foo.exe foo.c
```

The recipe prefix is the prefix starting each recipe line. 

__By default it is `'\t'`.__

And that's often a problem - because depending of the used editor / settings tabs may be converted to spaces. 

If you use spaces instead of tabs you get this mysterious error message : 

```
Makefile:xx: *** missing separator.  Stop.
```

## Solution

A solution to workaround that potential issue is to change the recipse prefix to something different : 

```make
# tell make to use '>' as recipe prefix
.RECIPEPREFIX = >

foo.exe: foo.c
> cc -o foo.exe foo.c
```

Now we have a visible character as recipe prefix which is much less error prone.

_The `.RECIPEPREFIX` directive is available since `make` version 4.0._
